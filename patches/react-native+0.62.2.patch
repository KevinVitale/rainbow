diff --git a/node_modules/react-native/React/Views/RCTView.m b/node_modules/react-native/React/Views/RCTView.m
index 831a1b5..76fdaab 100644
--- a/node_modules/react-native/React/Views/RCTView.m
+++ b/node_modules/react-native/React/Views/RCTView.m
@@ -780,6 +780,11 @@ - (void)displayLayer:(CALayer *)layer
     layer.contents = nil;
     layer.needsDisplayOnBoundsChange = NO;
     layer.mask = nil;
+    if (@available(iOS 13.0, *)) {
+      if (layer.cornerRadius < MIN(self.bounds.size.height, self.bounds.size.width) / 2) {
+        layer.cornerCurve = kCACornerCurveContinuous;
+      }
+    }
     return;
   }
 
diff --git a/node_modules/react-native/ReactCommon/jsi/JSCRuntime.cpp b/node_modules/react-native/ReactCommon/jsi/JSCRuntime.cpp
index a6e59fb..9fca524 100644
--- a/node_modules/react-native/ReactCommon/jsi/JSCRuntime.cpp
+++ b/node_modules/react-native/ReactCommon/jsi/JSCRuntime.cpp
@@ -20,7 +20,9 @@
 namespace facebook {
 namespace jsc {
 
-namespace detail {
+namespace detail
+{
+class ProtectionQueue;
 class ArgsConverter;
 } // namespace detail
 
@@ -71,28 +73,32 @@ class JSCRuntime : public jsi::Runtime {
 
  protected:
   friend class detail::ArgsConverter;
+  friend class detail::ProtectionQueue;
   class JSCSymbolValue final : public PointerValue {
 #ifndef NDEBUG
     JSCSymbolValue(JSGlobalContextRef ctx,
-                   const std::atomic<bool>& ctxInvalid,
+                   detail::ProtectionQueue& pq,
                    JSValueRef sym, std::atomic<intptr_t>& counter);
 #else
     JSCSymbolValue(JSGlobalContextRef ctx,
-                   const std::atomic<bool>& ctxInvalid,
+                   detail::ProtectionQueue& pq,
                    JSValueRef sym);
 #endif
     void invalidate() override;
+    void unprotect();
 
     JSGlobalContextRef ctx_;
-    const std::atomic<bool>& ctxInvalid_;
     // There is no C type in the JSC API to represent Symbol, so this stored
     // a JSValueRef which contains the Symbol.
     JSValueRef sym_;
+    detail::ProtectionQueue& protectionQueue_;
+    
 #ifndef NDEBUG
     std::atomic<intptr_t>& counter_;
 #endif
    protected:
     friend class JSCRuntime;
+    friend class detail::ProtectionQueue;
   };
 
   class JSCStringValue final : public PointerValue {
@@ -112,26 +118,34 @@ class JSCRuntime : public jsi::Runtime {
   };
 
   class JSCObjectValue final : public PointerValue {
-    JSCObjectValue(
-        JSGlobalContextRef ctx,
-        const std::atomic<bool>& ctxInvalid,
-        JSObjectRef obj
-#ifndef NDEBUG
-        ,
-        std::atomic<intptr_t>& counter
-#endif
-                   );
+    #ifndef NDEBUG
+        JSCObjectValue(   
+            JSGlobalContextRef ctx,
+            detail::ProtectionQueue& pq,
+            JSObjectRef obj,
+            std::atomic<intptr_t>& counter);
+    #else
+        JSCObjectValue(
+            JSGlobalContextRef context,
+            detail::ProtectionQueue& pq,
+            JSObjectRef obj);
+    #endif
+             
+    
 
     void invalidate() override;
+    void unprotect();
 
     JSGlobalContextRef ctx_;
-    const std::atomic<bool>& ctxInvalid_;
+    
     JSObjectRef obj_;
+    detail::ProtectionQueue& protectionQueue_;
 #ifndef NDEBUG
     std::atomic<intptr_t>& counter_;
 #endif
    protected:
     friend class JSCRuntime;
+    friend class detail::ProtectionQueue;
   };
 
   PointerValue* cloneSymbol(const Runtime::PointerValue* pv) override;
@@ -238,8 +252,10 @@ class JSCRuntime : public jsi::Runtime {
   void checkException(JSValueRef res, JSValueRef exc, const char* msg);
 
   JSGlobalContextRef ctx_;
-  std::atomic<bool> ctxInvalid_;
   std::string desc_;
+  // We make this a pointer so that we can control explicitly when it's deleted
+  // namely before the context is released.
+  mutable std::unique_ptr<detail::ProtectionQueue> protectionQueue_;
 #ifndef NDEBUG
   mutable std::atomic<intptr_t> objectCounter_;
   mutable std::atomic<intptr_t> symbolCounter_;
@@ -328,6 +344,98 @@ std::string to_string(void* value) {
 }
 } // namespace
 
+// UnprotectQueue
+namespace detail {
+class ProtectionQueue {
+ public:
+  ProtectionQueue()
+      : ctxInvalid_(false)
+      , shuttingDown_(false)
+#ifndef NDEBUG
+        ,
+        didShutdown_ {
+    false
+  }
+#endif
+  , unprotectorThread_(&ProtectionQueue::unprotectThread, this) {}
+
+  void setContextInvalid() {
+    std::lock_guard<std::mutex> locker(mutex_);
+    ctxInvalid_ = true;
+  }
+
+  void shutdown() {
+    {
+      std::lock_guard<std::mutex> locker(mutex_);
+      assert(ctxInvalid_);
+      shuttingDown_ = true;
+      notEmpty_.notify_one();
+    }
+    unprotectorThread_.join();
+  }
+
+  void push(JSCRuntime::JSCObjectValue* value) {
+    std::lock_guard<std::mutex> locker(mutex_);
+    assert(!didShutdown_);
+    queue_.push(value);
+    notEmpty_.notify_one();
+  }
+
+ private:
+  // This this the function that runs in the background deleting (and thus
+  // unprotecting JSObjectRefs as need be). This needs to be explicitly on a
+  // separate thread so that we don't have the API lock when `JSValueUnprotect`
+  // is called already (i.e. if we did this on the same thread that calls
+  // invalidate() on an Object then we might be in the middle of a GC pass, and
+  // already have the API lock).
+  void unprotectThread() {
+#if defined(__APPLE__)
+    pthread_setname_np("jsc-protectionqueue-unprotectthread");
+#endif
+
+    std::unique_lock<std::mutex> locker(mutex_);
+    while (!shuttingDown_ || !queue_.empty()) {
+      if (queue_.empty()) {
+        // This will wake up when shuttingDown_ becomes true
+        notEmpty_.wait(locker);
+      } else {
+        JSCRuntime::JSCObjectValue* value = queue_.front();
+        queue_.pop();
+        // We need to drop the lock here since this calls JSValueUnprotect and
+        // that may make another GC pass, which could call another finalizer
+        // and thus attempt to push to this queue then, and deadlock.
+        locker.unlock();
+        if (ctxInvalid_) {
+          value->ctx_ = nullptr;
+        }
+        value->unprotect();
+        locker.lock();
+      }
+    }
+#ifndef NDEBUG
+    didShutdown_ = true;
+#endif
+  }
+  // Used to lock the queue_/shuttingDown_ ivars
+  std::mutex mutex_;
+  // Used to signal queue_ empty status changing
+  std::condition_variable notEmpty_;
+  // The actual underlying queue
+  std::queue<JSCRuntime::JSCObjectValue*> queue_;
+  // A flag which is set before shutting down JSC
+  bool ctxInvalid_;
+  // A flag dictating whether or not we need to stop all execution
+  bool shuttingDown_;
+#ifndef NDEBUG
+  bool didShutdown_;
+#endif
+  // The thread that dequeues and processes the queue. Note this is the last
+  // member on purpose so the thread starts up after all state has been
+  // properly initialized
+  std::thread unprotectorThread_;
+};
+} // namespace detail
+
 JSCRuntime::JSCRuntime()
     : JSCRuntime(JSGlobalContextCreateInGroup(nullptr, nullptr)) {
   JSGlobalContextRelease(ctx_);
@@ -335,7 +443,7 @@ JSCRuntime::JSCRuntime()
 
 JSCRuntime::JSCRuntime(JSGlobalContextRef ctx)
     : ctx_(JSGlobalContextRetain(ctx)),
-      ctxInvalid_(false)
+      protectionQueue_(std::make_unique<detail::ProtectionQueue>())
 #ifndef NDEBUG
       ,
       objectCounter_(0),
@@ -351,8 +459,9 @@ JSCRuntime::~JSCRuntime() {
   // JSValueUnprotect() can no longer be called.  We use an
   // atomic<bool> to avoid unsafe unprotects happening after shutdown
   // has started.
-  ctxInvalid_ = true;
-  JSGlobalContextRelease(ctx_);
+   protectionQueue_->setContextInvalid();
+   JSGlobalContextRelease(ctx_);
+   protectionQueue_->shutdown();
 #ifndef NDEBUG
   assert(
       objectCounter_ == 0 && "JSCRuntime destroyed with a dangling API object");
@@ -427,7 +536,7 @@ bool smellsLikeES6Symbol(JSGlobalContextRef ctx, JSValueRef ref) {
 
 JSCRuntime::JSCSymbolValue::JSCSymbolValue(
     JSGlobalContextRef ctx,
-    const std::atomic<bool>& ctxInvalid,
+    detail::ProtectionQueue& pq,
     JSValueRef sym
 #ifndef NDEBUG
     ,
@@ -435,8 +544,8 @@ JSCRuntime::JSCSymbolValue::JSCSymbolValue(
 #endif
     )
     : ctx_(ctx),
-      ctxInvalid_(ctxInvalid),
-      sym_(sym)
+      sym_(sym),
+      protectionQueue_(pq)
 #ifndef NDEBUG
       ,
       counter_(counter)
@@ -450,13 +559,23 @@ JSCRuntime::JSCSymbolValue::JSCSymbolValue(
 }
 
 void JSCRuntime::JSCSymbolValue::invalidate() {
+  // See comment in JSCRuntime::JSCStringValue::invalidate as well as
+  // on ProtectionQueue::unprotectThread.
+  protectionQueue_.push((JSCObjectValue*)this);
+}
+
+void JSCRuntime::JSCSymbolValue::unprotect() {
 #ifndef NDEBUG
   counter_ -= 1;
 #endif
 
-  if (!ctxInvalid_) {
-    JSValueUnprotect(ctx_, sym_);
+  if (ctx_) {
+    
   }
+  // TODO
+//  if (!ctxInvalid_) {
+//    JSValueUnprotect(ctx_, sym_);
+//  }
   delete this;
 }
 
@@ -489,7 +608,7 @@ void JSCRuntime::JSCStringValue::invalidate() {
 
 JSCRuntime::JSCObjectValue::JSCObjectValue(
     JSGlobalContextRef ctx,
-    const std::atomic<bool>& ctxInvalid,
+    detail::ProtectionQueue& pq,
     JSObjectRef obj
 #ifndef NDEBUG
     ,
@@ -497,8 +616,8 @@ JSCRuntime::JSCObjectValue::JSCObjectValue(
 #endif
     )
     : ctx_(ctx),
-      ctxInvalid_(ctxInvalid),
-      obj_(obj)
+      obj_(obj),
+      protectionQueue_(pq)
 #ifndef NDEBUG
       ,
       counter_(counter)
@@ -511,32 +630,17 @@ JSCRuntime::JSCObjectValue::JSCObjectValue(
 }
 
 void JSCRuntime::JSCObjectValue::invalidate() {
+  // See comment in JSCRuntime::JSCStringValue::invalidate as well as
+  // on ProtectionQueue::unprotectThread.
+  protectionQueue_.push(this);
+}
+
+void JSCRuntime::JSCObjectValue::unprotect() {
 #ifndef NDEBUG
   counter_ -= 1;
 #endif
-  // When shutting down the VM, if there is a HostObject which
-  // contains or otherwise owns a jsi::Object, then the final GC will
-  // finalize the HostObject, leading to a call to invalidate().  But
-  // at that point, making calls to JSValueUnprotect will crash.
-  // It is up to the application to make sure that any other calls to
-  // invalidate() happen before VM destruction; see the comment on
-  // jsi::Runtime.
-  //
-  // Another potential concern here is that in the non-shutdown case,
-  // if a HostObject is GCd, JSValueUnprotect will be called from the
-  // JSC finalizer.  The documentation warns against this: "You must
-  // not call any function that may cause a garbage collection or an
-  // allocation of a garbage collected object from within a
-  // JSObjectFinalizeCallback. This includes all functions that have a
-  // JSContextRef parameter." However, an audit of the source code for
-  // JSValueUnprotect in late 2018 shows that it cannot cause
-  // allocation or a GC, and further, this code has not changed in
-  // about two years.  In the future, we may choose to reintroduce the
-  // mechanism previously used here which uses a separate thread for
-  // JSValueUnprotect, in order to conform to the documented API, but
-  // use the "unsafe" synchronous version on iOS 11 and earlier.
-
-  if (!ctxInvalid_) {
+  
+  if (ctx_) {
     JSValueUnprotect(ctx_, obj_);
   }
   delete this;
@@ -1260,9 +1364,9 @@ bool JSCRuntime::instanceOf(const jsi::Object& o, const jsi::Function& f) {
 jsi::Runtime::PointerValue* JSCRuntime::makeSymbolValue(
     JSValueRef symbolRef) const {
 #ifndef NDEBUG
-  return new JSCSymbolValue(ctx_, ctxInvalid_, symbolRef, symbolCounter_);
+  return new JSCSymbolValue(ctx_, *protectionQueue_, symbolRef, symbolCounter_);
 #else
-  return new JSCSymbolValue(ctx_, ctxInvalid_, symbolRef);
+  return new JSCSymbolValue(ctx_, *protectionQueue_, symbolRef);
 #endif
 }
 
@@ -1303,9 +1407,9 @@ jsi::Runtime::PointerValue* JSCRuntime::makeObjectValue(
     objectRef = JSObjectMake(ctx_, nullptr, nullptr);
   }
 #ifndef NDEBUG
-  return new JSCObjectValue(ctx_, ctxInvalid_, objectRef, objectCounter_);
+  return new JSCObjectValue(ctx_, *protectionQueue_, objectRef, objectCounter_);
 #else
-  return new JSCObjectValue(ctx_, ctxInvalid_, objectRef);
+  return new JSCObjectValue(ctx_, *protectionQueue_, objectRef);
 #endif
 }
 
